"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = FCM;

var _parse = require('parse');

var _parse2 = _interopRequireDefault(_parse);

var _npmlog = require('npmlog');

var _npmlog2 = _interopRequireDefault(_npmlog);

var _app = require('firebase-admin/app');

var _messaging = require('firebase-admin/messaging');

var _PushAdapterUtils = require('./PushAdapterUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LOG_PREFIX = 'parse-server-push-adapter FCM';
var FCMRegistrationTokensMax = 500;
var FCMTimeToLiveMax = 4 * 7 * 24 * 60 * 60; // FCM allows a max of 4 weeks

function FCM(args) {
  if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) !== 'object' || !args.firebaseServiceAccount) {
    throw new _parse2.default.Error(_parse2.default.Error.PUSH_MISCONFIGURED, 'FCM Configuration is invalid');
  }

  var app = void 0;
  if ((0, _app.getApps)().length === 0) {
    app = (0, _app.initializeApp)({ credential: (0, _app.cert)(args.firebaseServiceAccount) });
  } else {
    app = (0, _app.getApp)();
  }
  this.sender = (0, _messaging.getMessaging)(app);
}

FCM.FCMRegistrationTokensMax = FCMRegistrationTokensMax;

/**
 * Send fcm request.
 * @param {Object} data The data we need to send, the format is the same with api request body
 * @param {Array} devices A array of devices
 * @returns {Object} Array of resolved promises
 */

FCM.prototype.send = function (data, devices) {
  var _this = this;

  if (!data || !devices || !Array.isArray(devices)) {
    _npmlog2.default.warn(LOG_PREFIX, 'invalid push payload');
    return;
  }

  // We can only have 500 recepients per send, so we need to slice devices to
  // chunk if necessary
  var slices = sliceDevices(devices, FCM.FCMRegistrationTokensMax);

  var sendToDeviceSlice = function sendToDeviceSlice(deviceSlice) {
    var pushId = (0, _PushAdapterUtils.randomString)(10);
    var timestamp = Date.now();

    // Build a device map
    var devicesMap = deviceSlice.reduce(function (memo, device) {
      memo[device.deviceToken] = device;
      return memo;
    }, {});

    var deviceTokens = Object.keys(devicesMap);
    var fcmPayload = generateFCMPayload(data, pushId, timestamp, deviceTokens);
    var length = deviceTokens.length;
    _npmlog2.default.info(LOG_PREFIX, 'sending push to ' + length + ' devices');

    return _this.sender.sendEachForMulticast(fcmPayload.data).then(function (response) {
      var promises = [];
      var failedTokens = [];
      var successfulTokens = [];

      response.responses.forEach(function (resp, idx) {
        if (resp.success) {
          successfulTokens.push(deviceTokens[idx]);
          promises.push(createSuccessfulPromise(deviceTokens[idx], devicesMap[deviceTokens[idx]].deviceType));
        } else {
          failedTokens.push(deviceTokens[idx]);
          promises.push(createErrorPromise(deviceTokens[idx], devicesMap[deviceTokens[idx]].deviceType, resp.error));
          _npmlog2.default.error(LOG_PREFIX, 'failed to send to ' + deviceTokens[idx] + ' with error: ' + JSON.stringify(resp.error));
        }
      });

      if (failedTokens.length) {
        _npmlog2.default.error(LOG_PREFIX, 'tokens with failed pushes: ' + JSON.stringify(failedTokens));
      }

      if (successfulTokens.length) {
        _npmlog2.default.verbose(LOG_PREFIX, 'tokens with successful pushes: ' + JSON.stringify(successfulTokens));
      }

      return Promise.all(promises);
    });
  };

  var allPromises = Promise.all(slices.map(sendToDeviceSlice)).catch(function (err) {
    _npmlog2.default.error(LOG_PREFIX, 'error sending push: ' + err);
  });

  return allPromises;
};

/**
 * Generate the fcm payload from the data we get from api request.
 * @param {Object} requestData The request body
 * @param {String} pushId A random string
 * @param {Number} timeStamp A number in milliseconds since the Unix Epoch
 * @returns {Object} A payload for FCM
 */
function generateFCMPayload(requestData, pushId, timeStamp, deviceTokens) {
  delete requestData['where'];

  var payloadToUse = {
    data: {},
    push_id: pushId,
    time: new Date(timeStamp).toISOString()
  };

  // Use rawPayload instead of the GCM implementation if it exists
  if (requestData.hasOwnProperty('rawPayload')) {
    payloadToUse.data = _extends({}, requestData.rawPayload, {
      tokens: deviceTokens
    });
  } else {
    // Android payload according to GCM implementation
    var androidPayload = {
      android: {
        priority: 'high'
      },
      tokens: deviceTokens
    };

    if (requestData.hasOwnProperty('notification')) {
      androidPayload.notification = requestData.notification;
    }

    if (requestData.hasOwnProperty('data')) {
      androidPayload.data = requestData.data;
    }

    if (requestData['expiration_time']) {
      var expirationTime = requestData['expiration_time'];
      // Convert to seconds
      var timeToLive = Math.floor((expirationTime - timeStamp) / 1000);
      if (timeToLive < 0) {
        timeToLive = 0;
      }
      if (timeToLive >= FCMTimeToLiveMax) {
        timeToLive = FCMTimeToLiveMax;
      }

      androidPayload.android.ttl = timeToLive;
    }

    payloadToUse.data = androidPayload;
  }

  return payloadToUse;
}

/**
 * Slice a list of devices to several list of devices with fixed chunk size.
 * @param {Array} devices An array of devices
 * @param {Number} chunkSize The size of the a chunk
 * @returns {Array} An array which contains several arrays of devices with fixed chunk size
 */
function sliceDevices(devices, chunkSize) {
  var chunkDevices = [];
  while (devices.length > 0) {
    chunkDevices.push(devices.splice(0, chunkSize));
  }
  return chunkDevices;
}

/**
 * Creates an errorPromise for return.
 *
 * @param {String} token Device-Token
 * @param {String} deviceType Device-Type
 * @param {String} errorMessage ErrrorMessage as string
 */
function createErrorPromise(token, deviceType, errorMessage) {
  return Promise.resolve({
    transmitted: false,
    device: {
      deviceToken: token,
      deviceType: deviceType
    },
    response: { error: errorMessage }
  });
}

/**
 * Creates an successfulPromise for return.
 *
 * @param {String} token Device-Token
 * @param {String} deviceType Device-Type
 */
function createSuccessfulPromise(token, deviceType) {
  return Promise.resolve({
    transmitted: true,
    device: {
      deviceToken: token,
      deviceType: deviceType
    }
  });
}

FCM.generateFCMPayload = generateFCMPayload;

/* istanbul ignore else */
if (process.env.TESTING) {
  FCM.sliceDevices = sliceDevices;
}